package Go_LeetCode

import "container/list"

func CanCompleteCircuit(gas []int, cost []int) int {
	var good = goodArray(gas, cost)
	for i := range good {
		if good[i] {
			return i
		}
	}
	return -1
}

//func goodArray(g, c []int) []bool {
//	var N = len(g)
//	var M = N << 1
//	var arr = make([]int, M)
//	for i := 0; i < N; i++ {
//		arr[i] = g[i] - c[i]
//		arr[i+N] = g[i] - c[i]
//	}
//	for i := 1; i < M; i++ {
//		arr[i] += arr[i-1]
//	}
//	// 举个例子说明一下
//	// 比如纯能数组(也就是燃料 - 距离之后)的数组 :
//	// 纯能数组 = 3, 2,-6, 2, 3,-4, 6
//	// 数组下标 = 0  1  2  3  4  5  6
//	// 客观上说:
//	// 0位置不是良好出发点
//	// 1位置不是良好出发点
//	// 2位置不是良好出发点
//	// 3位置是良好出发点
//	// 4位置不是良好出发点
//	// 5位置不是良好出发点
//	// 6位置是良好出发点
//	// 把数组增倍之后 :
//	// arr   = 3, 2,-6, 2, 3,-4, 6, 3, 2,-6, 2, 3,-4, 6
//	// 然后计算前缀和 :
//	// arr   = 3, 5,-1, 1, 4, 0, 6, 9,11, 5, 7,10, 6,12
//	// index = 0  1  2  3  4  5  6  7  8  9 10 11 12 13
//	// 这些就是上面发生的过程
//	// 接下来生成长度为N的窗口
//	var w list.List
//	for i := 0; i < N; i++ {
//		for w.Len() > 0 && arr[w.Back().Value.(int)] >= arr[i] {
//			w.Remove(w.Back())
//		}
//		w.PushBack(i)
//	}
//	// 上面的过程，就是先遍历N个数，然后建立窗口
//	// arr   =[3, 5,-1, 1, 4, 0, 6],9,11, 5, 7,10, 6,12
//	// index = 0  1  2  3  4  5  6  7  8  9 10 11 12 13
//	// w中的内容如下:
//	// index:  2 5 6
//	// value: -1 0 6
//	// 左边是头，右边是尾，从左到右严格变大
//	// 此时代表最原始的arr的这部分的数字:
//	// 原始的值 = [3, 2,-6, 2, 3,-4, 6],3, 2,-6, 2, 3,-4, 6
//	// 原始下标 =  0  1  2  3  4  5  6  0  1  2  3  4  5  6
//	// 上面这个窗口中，累加和最薄弱的点，就是w中最左信息
//	// 也就是会累加出，-1这个值，所以会走不下去。
//	// 宣告了此时0位置不是良好出发点。
//	// 接下来的代码，就是依次考察每个点是不是良好出发点。
//	// 目前的信息是:
//	// 计算的前缀和 :
//	// arr   =[3, 5,-1, 1, 4, 0, 6],9,11, 5, 7,10, 6,12
//	// index = 0  1  2  3  4  5  6  7  8  9 10 11 12 13
//	// w中的内容如下:
//	// index:  2 5 6
//	// value: -1 0 6
//	// 此时代表最原始的arr的这部分的数字:
//	// 原始的值 = [3, 2,-6, 2, 3,-4, 6],3, 2,-6, 2, 3,-4, 6
//	// 原始下标 =  0  1  2  3  4  5  6  0  1  2  3  4  5  6
//	// 现在让窗口往下移动
//	// 计算的前缀和 :
//	// arr   = 3,[5,-1, 1, 4, 0, 6, 9],11, 5, 7,10, 6,12
//	// index = 0  1  2  3  4  5  6  7   8  9 10 11 12 13
//	// w中的内容如下:
//	// index:  2 5 6 7
//	// value: -1 0 6 9
//	// 此时代表最原始的arr的这部分的数字:
//	// 原始的值 =  3,[2,-6, 2, 3,-4, 6, 3],2,-6, 2, 3,-4, 6
//	// 原始下标 =  0  1  2  3  4  5  6  0  1  2  3  4  5  6
//	// 上面这个窗口中，累加和最薄弱的点，就是w中最左信息
//	// 但是w最左的值是-1啊！而这个窗口中最薄弱的累加和是-4啊。
//	// 对！所以最薄弱信息 = 窗口中的最左信息 - 窗口左侧刚出去的数(代码中的offset!)
//	// 所以，最薄弱信息 = -1 - 0位置的3(窗口左侧刚出去的数) = -4
//	// 看到了吗？最薄弱信息，依靠这种方式，加工出来了！
//	// 宣告了此时1位置不是良好出发点。
//	// 我们继续，让窗口往下移动
//	// 计算的前缀和 :
//	// arr   = 3, 5,[-1, 1, 4, 0, 6, 9,11], 5, 7,10, 6,12
//	// index = 0  1   2  3  4  5  6  7  8   9 10 11 12 13
//	// w中的内容如下:
//	// index:  2  5  6  7  8
//	// value: -1  0  6  9 11
//	// 此时代表最原始的arr的这部分的数字:
//	// 原始的值 =  3, 2,[-6, 2, 3,-4, 6, 3, 2],-6, 2, 3,-4, 6
//	// 原始下标 =  0  1   2  3  4  5  6  0  1   2  3  4  5  6
//	// 上面这个窗口中，累加和最薄弱的点，就是w中最左信息
//	// 但是w最左的值是-1啊！而这个窗口中最薄弱的累加和是-6啊。
//	// 对！所以最薄弱信息 = 窗口中的最左信息 - 窗口左侧刚出去的数(代码中的offset!)
//	// 所以，最薄弱信息 = -1 - 1位置的5(窗口左侧刚出去的数) = -6
//	// 看到了吗？最薄弱信息，依靠这种方式，加工出来了！
//	// 宣告了此时2位置不是良好出发点。
//	// 我们继续，让窗口往下移动
//	// 计算的前缀和 :
//	// arr   = 3, 5, -1,[1, 4, 0, 6, 9,11, 5], 7,10, 6,12
//	// index = 0  1   2  3  4  5  6  7  8  9  10 11 12 13
//	// w中的内容如下:
//	// index:  5  9
//	// value:  0  5
//	// 没错，9位置的5进来，让6、7、8位置从w的尾部弹出了，
//	// 同时原来在w中的2位置已经过期了，所以也弹出了，因为窗口左边界已经划过2位置了
//	// 此时代表最原始的arr的这部分的数字:
//	// 原始的值 =  3, 2, -6,[2, 3,-4, 6, 3, 2, -6],2, 3,-4, 6
//	// 原始下标 =  0  1   2  3  4  5  6  0  1   2  3  4  5  6
//	// 上面这个窗口中，累加和最薄弱的点，就是w中最左信息
//	// 但是w最左的值是0啊！而这个窗口中最薄弱的累加和是1啊
//	// 对！所以最薄弱信息 = 窗口中的最左信息 - 窗口左侧刚出去的数(代码中的offset!)
//	// 所以，最薄弱信息 = 0 - 2位置的-1(窗口左侧刚出去的数) = 1
//	// 看到了吗？最薄弱信息，依靠这种方式，加工出来了！
//	// 宣告了此时3位置是良好出发点。
//	// 往下同理
//	var ans = make([]bool, N)
//	// offset表示当前选取的出发点前一个位置的值，当前范围内最薄弱的点-offset 如果不小于0，说明汽车
//	// 不会在路上没油 说明汽车能走完全程 说明当前范围的起点i位置 是一个可以出发的点
//	for offset, i, j := 0, 0, N; j < M; offset = arr[i] {
//
//		if arr[w.Front().Value.(int)]-offset >= 0 {
//			ans[i] = true
//		}
//		if w.Front().Value.(int) == i {
//			w.Remove(w.Front())
//		}
//		for w.Len() > 0 && arr[w.Back().Value.(int)] >= arr[j] {
//			w.Remove(w.Back())
//		}
//		w.PushBack(j)
//		i++
//		j++
//	}
//	return ans
//}

func goodArray(g, c []int) []bool {
	N := len(g)
	M := N * 2
	arr := make([]int, M)

	for i := 0; i < N; i++ {
		arr[i] = g[i] - c[i]
		arr[i+N] = g[i] - c[i]
	}

	for i := 1; i < M; i++ {
		arr[i] += arr[i-1]
	}

	w := list.New()
	for i := 0; i < N; i++ {
		for w.Len() > 0 && arr[w.Back().Value.(int)] >= arr[i] {
			w.Remove(w.Back())
		}
		w.PushBack(i)
	}

	ans := make([]bool, N)
	for offset, i, j := 0, 0, N; j < M; offset, i, j = arr[i], i+1, j+1 {
		if arr[w.Front().Value.(int)]-offset >= 0 {
			ans[i] = true
		}
		if w.Front().Value.(int) == i {
			w.Remove(w.Front())
		}
		for w.Len() > 0 && arr[w.Back().Value.(int)] >= arr[j] {
			w.Remove(w.Back())
		}
		w.PushBack(j)
	}

	return ans
}
